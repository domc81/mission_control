import { mutation, query } from "./_generated/server";
import { v } from "convex/values";
import { encryptCredential, decryptCredential } from "./encryption";

export const registerAgent = mutation({
  args: { 
    name: v.string(), 
    role: v.string(),
    capabilities: v.optional(v.array(v.string())),
    workspace: v.optional(v.string()),
    heartbeatOffset: v.optional(v.number())
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const agentId = await ctx.db.insert("agents", {
      name: args.name, 
      role: args.role,
      capabilities: args.capabilities,
      workspace: args.workspace,
      heartbeatOffset: args.heartbeatOffset,
      status: "idle", 
      createdAt: now, 
      updatedAt: now
    });
    await ctx.db.insert("auditLog", {
      eventType: "agent_registered", actorId: "system", targetType: "agent",
      targetId: agentId.toString(), details: `Agent ${args.name} (${args.role}) registered`, timestamp: now
    });
    return agentId;
  }
});

export const heartbeat = mutation({
  args: { agentId: v.id("agents") },
  handler: async (ctx, args) => {
    const now = Date.now();
    await ctx.db.patch(args.agentId, { heartbeatAt: now, updatedAt: now });
  }
});

export const updateStatus = mutation({
  args: { agentId: v.id("agents"), status: v.union(v.literal("active"), v.literal("idle"), v.literal("busy"), v.literal("offline")) },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.agentId, { status: args.status, updatedAt: Date.now() });
  }
});

export const createTask = mutation({
  args: {
    title: v.string(), description: v.optional(v.string()), assignees: v.array(v.string()),
    priority: v.optional(v.union(v.literal("low"), v.literal("medium"), v.literal("high"), v.literal("urgent"))),
    creatorId: v.string(), parentTaskId: v.optional(v.id("tasks"))
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const taskId = await ctx.db.insert("tasks", {
      title: args.title, description: args.description, status: "pending",
      priority: args.priority || "medium", assignees: args.assignees, creatorId: args.creatorId,
      parentTaskId: args.parentTaskId, createdAt: now, updatedAt: now
    });
    for (const assigneeId of args.assignees) {
      await ctx.db.insert("notifications", {
        agentId: assigneeId, type: "task_assigned", content: `New task: ${args.title}`,
        relatedTaskId: taskId, delivered: false, createdAt: now
      });
    }
    await ctx.db.insert("activities", {
      agentId: args.creatorId, type: "task_started", message: `Created: ${args.title}`,
      relatedTaskId: taskId, timestamp: now
    });
    return taskId;
  }
});

export const updateTaskStatus = mutation({
  args: {
    taskId: v.id("tasks"),
    status: v.union(v.literal("pending"), v.literal("in_progress"), v.literal("review"), v.literal("completed"), v.literal("archived")),
    agentId: v.string()
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const updates: any = { status: args.status, updatedAt: now };
    if (args.status === "completed") updates.completedAt = now;
    await ctx.db.patch(args.taskId, updates);
    const task = await ctx.db.get(args.taskId);
    if (task) {
      for (const assigneeId of task.assignees) {
        await ctx.db.insert("notifications", {
          agentId: assigneeId, type: "task_completed", content: `Task "${task.title}" ${args.status}`,
          relatedTaskId: args.taskId, delivered: false, createdAt: now
        });
      }
    }
    await ctx.db.insert("activities", {
      agentId: args.agentId, type: args.status === "completed" ? "task_completed" : "task_started",
      message: `Task "${task?.title || args.taskId}" ${args.status}`, relatedTaskId: args.taskId, timestamp: now
    });
  }
});

export const storeCredential = mutation({
  args: {
    agentId: v.string(), service: v.string(), plaintextKey: v.string(), permissions: v.array(v.string())
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const { encryptedKey, iv, tag } = await encryptCredential(args.plaintextKey);
    const credentialId = await ctx.db.insert("credentials", {
      agentId: args.agentId, service: args.service, encryptedKey, iv, tag,
      permissions: args.permissions, createdAt: now, updatedAt: now
    });
    await ctx.db.insert("auditLog", {
      eventType: "credential_stored", actorId: args.agentId, targetType: "credential",
      targetId: credentialId.toString(), details: `Stored ${args.service}`, timestamp: now
    });
    return credentialId;
  }
});

export const getCredential = mutation({
  args: { agentId: v.id("agents"), credentialId: v.id("credentials") },
  handler: async (ctx, args) => {
    const now = Date.now();
    const credential = await ctx.db.get(args.credentialId);
    if (!credential) throw new Error("Credential not found");
    if (credential.agentId !== args.agentId.toString()) {
      await ctx.db.insert("auditLog", {
        eventType: "credential_access_denied", actorId: args.agentId.toString(), targetType: "credential",
        targetId: args.credentialId.toString(), details: `Denied ${credential.service}`, timestamp: now
      });
      throw new Error("Access denied");
    }
    const plaintext = await decryptCredential(credential.encryptedKey, credential.iv, credential.tag);
    await ctx.db.patch(args.credentialId, { lastAccessedAt: now });
    await ctx.db.insert("auditLog", {
      eventType: "credential_accessed", actorId: args.agentId.toString(), targetType: "credential",
      targetId: args.credentialId.toString(), details: `Accessed ${credential.service}`, timestamp: now
    });
    return plaintext;
  }
});

export const sendMessage = mutation({
  args: { taskId: v.id("tasks"), authorId: v.string(), content: v.string(), mentions: v.array(v.string()) },
  handler: async (ctx, args) => {
    const now = Date.now();
    const messageId = await ctx.db.insert("messages", {
      taskId: args.taskId, authorId: args.authorId, content: args.content, mentions: args.mentions, createdAt: now
    });
    for (const mentionedId of args.mentions) {
      await ctx.db.insert("notifications", {
        agentId: mentionedId, type: "mention", content: `${args.authorId}: "${args.content.slice(0, 50)}..."`,
        relatedTaskId: args.taskId, delivered: false, createdAt: now
      });
    }
    await ctx.db.insert("activities", {
      agentId: args.authorId, type: "message_sent", message: "Sent message", relatedTaskId: args.taskId, timestamp: now
    });
    return messageId;
  }
});

export const getNotifications = query({
  args: { agentId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db.query("notifications")
      .withIndex("by_agent", q => q.eq("agentId", args.agentId))
      .filter(q => q.eq(q.field("delivered"), false))
      .collect();
  }
});

export const markNotificationDelivered = mutation({
  args: { notificationId: v.id("notifications") },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.notificationId, { delivered: true });
  }
});

export const getActiveTasks = query({
  args: {},
  handler: async (ctx) => {
    return await ctx.db.query("tasks")
      .withIndex("by_status")
      .filter(q => q.or(
        q.eq(q.field("status"), "pending"),
        q.eq(q.field("status"), "in_progress"),
        q.eq(q.field("status"), "review")
      ))
      .collect();
  }
});

export const getAllAgents = query({
  args: {},
  handler: async (ctx) => await ctx.db.query("agents").collect()
});

export const getRecentActivities = query({
  args: { limit: v.optional(v.number()) },
  handler: async (ctx, args) => {
    const activities = await ctx.db.query("activities").withIndex("by_timestamp").collect();
    const sorted = activities.sort((a, b) => b.timestamp - a.timestamp).slice(0, args.limit || 50);
    const agents = await ctx.db.query("agents").collect();
    const agentMap = new Map(agents.map(a => [a._id.toString(), a]));
    return sorted.map(a => ({ ...a, agentName: agentMap.get(a.agentId)?.name || a.agentId }));
  }
});

export const getDashboard = query({
  args: {},
  handler: async (ctx) => {
    const agents = await ctx.db.query("agents").collect();
    const tasks = await ctx.db.query("tasks").collect();
    const activities = await ctx.db.query("activities").withIndex("by_timestamp").collect();
    const sortedActivities = activities.sort((a, b) => b.timestamp - a.timestamp).slice(0, 20);
    const agentsMap = new Map(agents.map(a => [a._id.toString(), a]));
    return {
      agents: agents.map(a => ({ id: a._id.toString(), name: a.name, role: a.role, status: a.status, lastHeartbeat: a.heartbeatAt })),
      taskStats: { total: tasks.length, pending: tasks.filter(t => t.status === "pending").length, inProgress: tasks.filter(t => t.status === "in_progress").length, completed: tasks.filter(t => t.status === "completed").length },
      recentActivities: sortedActivities.map(a => ({ ...a, agentName: agentsMap.get(a.agentId)?.name || a.agentId })),
    };
  }
});

// ========== KANBAN BOARD FUNCTIONS ==========

export const getTasksByStatus = query({
  args: {},
  handler: async (ctx) => {
    const tasks = await ctx.db.query("tasks").collect();
    const agents = await ctx.db.query("agents").collect();
    const agentMap = new Map(agents.map(a => [a._id.toString(), a]));
    return {
      pending: tasks.filter(t => t.status === "pending").map(t => ({ ...t, assigneesData: t.assignees.map(id => agentMap.get(id?.toString())?.name || id) })),
      in_progress: tasks.filter(t => t.status === "in_progress").map(t => ({ ...t, assigneesData: t.assignees.map(id => agentMap.get(id?.toString())?.name || id) })),
      review: tasks.filter(t => t.status === "review").map(t => ({ ...t, assigneesData: t.assignees.map(id => agentMap.get(id?.toString())?.name || id) })),
      completed: tasks.filter(t => t.status === "completed").map(t => ({ ...t, assigneesData: t.assignees.map(id => agentMap.get(id?.toString())?.name || id) })),
    };
  }
});

// ========== ACTIVITY FILTERS ==========

export const getActivitiesFiltered = query({
  args: { 
    agentId: v.optional(v.string()),
    type: v.optional(v.string()),
    since: v.optional(v.number()),
    limit: v.optional(v.number())
  },
  handler: async (ctx, args) => {
    let activities = await ctx.db.query("activities").withIndex("by_timestamp").collect();
    activities = activities.sort((a, b) => b.timestamp - a.timestamp);
    
    if (args.agentId) {
      activities = activities.filter(a => a.agentId === args.agentId);
    }
    if (args.type) {
      activities = activities.filter(a => a.type === args.type);
    }
    if (args.since) {
      activities = activities.filter(a => a.timestamp >= args.since);
    }
    
    const agents = await ctx.db.query("agents").collect();
    const agentMap = new Map(agents.map(a => [a._id.toString(), a]));
    
    return activities
      .slice(0, args.limit || 50)
      .map(a => ({ ...a, agentName: agentMap.get(a.agentId)?.name || a.agentId }));
  }
});

// ========== DOCUMENT PANEL CRUD ==========

export const getDocuments = query({
  args: { type: v.optional(v.union(v.literal("spec"), v.literal("memo"), v.literal("decision"), v.literal("other"))) },
  handler: async (ctx, args) => {
    if (args.type) {
      return await ctx.db.query("documents").filter(q => q.eq(q.field("type"), args.type)).collect();
    }
    return await ctx.db.query("documents").collect();
  }
});

export const getDocument = query({
  args: { documentId: v.id("documents") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.documentId);
  }
});

export const createDocument = mutation({
  args: {
    title: v.string(),
    content: v.string(),
    type: v.union(v.literal("spec"), v.literal("memo"), v.literal("decision"), v.literal("other")),
    authorId: v.string(),
    relatedTaskId: v.optional(v.id("tasks"))
  },
  handler: async (ctx, args) => {
    const now = Date.now();
    const docId = await ctx.db.insert("documents", {
      title: args.title,
      content: args.content,
      type: args.type,
      authorId: args.authorId,
      relatedTaskId: args.relatedTaskId,
      createdAt: now,
      updatedAt: now
    });
    await ctx.db.insert("activities", {
      agentId: args.authorId,
      type: "task_started",
      message: `Created document: ${args.title}`,
      relatedTaskId: args.relatedTaskId,
      timestamp: now
    });
    return docId;
  }
});

export const updateDocument = mutation({
  args: {
    documentId: v.id("documents"),
    title: v.optional(v.string()),
    content: v.optional(v.string()),
    authorId: v.string()
  },
  handler: async (ctx, args) => {
    const updates: any = { updatedAt: Date.now() };
    if (args.title) updates.title = args.title;
    if (args.content) updates.content = args.content;
    
    await ctx.db.patch(args.documentId, updates);
    await ctx.db.insert("activities", {
      agentId: args.authorId,
      type: "task_started",
      message: `Updated document`,
      timestamp: Date.now()
    });
  }
});

export const deleteDocument = mutation({
  args: { documentId: v.id("documents"), authorId: v.string() },
  handler: async (ctx, args) => {
    await ctx.db.delete(args.documentId);
    await ctx.db.insert("activities", {
      agentId: args.authorId,
      type: "task_completed",
      message: `Deleted document`,
      timestamp: Date.now()
    });
  }
});
